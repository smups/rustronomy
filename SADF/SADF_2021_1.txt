--------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++ SIMPLE ASTRONOMICAL DATA FORMAT +++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
--------------------------------------------------------------------------------

SADF - The Simple Astronomical Data Format
Version 2021.1
Creation date: 01/12/2021
Author: Raúl Wolters (Instituut Lorentz, Universiteit Leiden, the Netherlands)
contact: rwolters@lorentz.leidenuniv.nl

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 1. Introduction +++
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
+++ 1.1 Raison d'être of SADF +++

The Simple Astronomical Data Format (SADF) was designed to improve upon the 
commonly used FITS standard developed by NASA in the 1970's for use in
astronomy. The FITS standard is rather clunky and does not support compression
or data verification methods natively. Despite these disadvantages, FITS is
still widely used within astronomy for it's versatility in allowing extensions
of the standard. SADF aims to keep best practices from FITS and improving upon
the less-than-ideal aspects of the FITS standard.

In additon, SADF is and always will be an open standard as per the definition of
the free software foundation. 

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 1.2 Overview +++

A SADF file consists of a header and data blocks. A SADF standard compliant file
must always contain a header. The header essentially serves as a table of
contents for the SADF file. Each data block present in the file is listed in the
header as a Header Index Block (HIB).

SADF files contain no padding between the header/datablocks. In additon, both
the header and data blocks may be of arbitrary length to allow flexible encoding
formats. For this reason, the header contains pointers (read: byte indices) and 
lengths for all data blocks, whereas the header itself always starts at index 0.

Data blocks can have various types. In this standard, metadata blocks, plain
text, up to 16-dimensional arrays and tables(maps) are supported. Users may also
extend the standard and define their own data block types.

The metadata block contains a lot of critical information about a SADF file.
Each data block may link to a metadata block that contains metadata relevant to
that data block. Multiple data blocks may be associated with a single metadata 
block(2), but no more than one metadata block can be assigned to each data 
block.

The SADF standard natively supports encryption, digital signing of data and
compression algorithms. If a data block is encrypted, signed or compressed, the
type of compression, type of encryption and signature are all stored in the
metadata block associated with the data block in question. The metadata(1) part
of the metadata block associated with a data block shall be appended to the data
block before signing/encrypting the pair, but after compressing the data block
itself, since data block compression must always take place before signing.

Data blocks (including metadata blocks) may appear in any order in a SADF file ( 
although none may appear before the header). Therefore, data blocks that refer 
to other data blocks must do so using the data block identification number 
(DB_ID). The header provides an index linking these DB_IDs to actual positions 
in the file using the ptr data type.

Finally, an example is shown of a possible SADF file:

[data block]    [short description]
header          6 data blocks: (1 -> ...), (2 -> ...), (3 -> ...) etc...
Data Block 1    (metadata for block 2 and 3)
Data Block 2    (data) -> (metadata) 1
Data Block 3    (data) -> (metadata) 1
Data Block 4    (metadata for block 6)
Data Block 5    (data) -> (no metadata) 0 
Data Block 6    (data) -> (metadata) 4
etc...

(1)

(2) This feature can be used, for instance, to sign multiple data blocks with
    the same signature.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 1.3 Data Types +++

[Code]	[Size]  [Abbreviation]	[Description]
//Raw byte array
0x0000  unsized raw             raw byte array of unknown length (1)

//Boolean
0x0001	1       bool		    8-bit boolean (0=true, else=false)

//Unsigned Integers
0x0008	1       u08		        unsigned 8-bit integer
0x0016 	2       u16		        unsigned 16-bit integer
0x0032 	4       u32		        unsigned 32-bit integer
0x0064 	8       u64		        unsigned 64-bit integer

//Signed Integers
0x0010 	2       i16		        signed 16-bit integer
0x0020 	4       i32		        signed 32-bit integer
0x0040 	8       i64		        signed 64-bit integer

//Signed floats
0x0f20 	4       f32		        signed 32-bit float (IEEE compliant)
0x0f40 	8       f64		        signed 64-bit float (IEEE compliant)

//Character Arrays
0xca08 	unsized utf8	        UTF-8 encoded charachter array (1)
0xca16  unsized utf16           UTF-16 encoded charachter array (1)

//Pointer
0xa064	4       ptr  		    64-bit pointer

//Complex numbers
0xc016  8       xu16            unsigned 16x2-bit complex integer number
0xc032  16      xu32            unsigned 32x2-bit complex integer number
0xc064  32      xu64            unsigned 64x2-bit complex integer number

0xc010  8       xi16            signed 16x2-bit complex integer number
0xc020  16      xi32            signed 32x2-bit complex integer number
0xc040  32      xi64            signed 64x2-bit complex integer number

0xcf20  16      xf32            signed 32x2-bit floating point complex number
0xcf40  32      xf64            signed 64x2-bit floating point complex number

//User defined types
0xb___  unsized ...             user-reserved range (2, 1)

//Range notation for slices
A range, written as x-y, includes x but excludes y.

(1) The raw, charachter array and ALL user defined types are unsized. Hence, the
    length of fields using these data types MUST be specified explicitly.

(2) Users may define their own types in the 0xb___ range. These type definitions
    are not supported guaranteed to exist in standard-conforming implementations
    and hence must be implemented by the user themself.

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 2. The Header +++
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
+++ 2.1 Header +++

The header starts off with a u16 integer stating the version number of the SADF
standard that was used to encode the file, followed by a u16 integer listing the
number of data blocks, and finally an unordered list of Header Index Blocks
(HIB's) is appended. Note that each HIB is always 20 bytes long.

The following table maps version number values to their corresponding SADF
versions:

[hex]   [decimal]   [SADF version]
0x00d3  211          2021.1

A header can, theoretically, hold 65•535 entries. This means that the maximum
header size is 1•310•702 bytes, or about 1.3MB. Hence, 1•310•702 bytes must
always be avaliable for header decoding in programs implementing SADF reading
functionality, unless the total file size is smaller than 1•310•702 bytes, in
which case the entire file must be loaded in one buffer in order to guarantee
the entire header is avaliable(1).

Note: Since the length of the data blocks is specified in the header, the 
required buffer size to read the data blocks is always known and no memory needs
to go to waste when copying the data blocks into memory, unlike in the header
reading process listed above.

[byte]	[type]	[field]
0,1     u16     version number (required)
2,3	    u16     number of indexed data blocks (required)
4-24	HIB     HIB #1 (optional)
24-44	HIB     HIB #2 (optional)
...	    ...     ...
x-x+20	HIB     Final HIB

(1) This buffer need not be thrown away and may be re-used by the implementation
    to parse the remaining file contents.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 2.2 Header Index Block +++

A Header Index Block (HIB) points to a data block in the file. They are
used exclusively in the header part of the file. An HIB is always 20 bytes long.

[byte]	[type]	[field]
0,1     u16 	data block identification number (DB_ID)
2-10    ptr	    data block start (DB_ST)
10-18   u64	    data block length (DB_SI)
18,19   u16	    data block type identifier (DB_TY)

The identification number (DB_ID) of a data block serves for internal refrences;
i.e. when data blocks must refrence eachother. The Data Block Start (DB_ST)
pointer points to the byte index at which the data block in question starts.
The data block length (DB_SI) field specifies the length of the data blocks in
bytes.

Finally, the data block type identifier (DB_TY) specifies the format that was
used to store the data block. The following DB_TY values have specific meanings:

[value] [function]
0x0000  plain text
0x0001  1-dimensional array (1)
0x0002  2-dimensional array/image (1)
...     n-dimensional array (1)
0x000f  16-dimensional array (1)
0x00f0  table (2)
0xb___  user-reserved range (3)
0xffff  metadata

(1) Arrays may only consist of one data type. For more information, see the 
    "Array Data Block (0x0001-0x000f)" section of this document.
(2) Tables may contain keyword - value pairs of arbitrary type, although all
    keywords and all values must have the same type. For more information, see
    the "Table Data Block (0x00f0)" section of this document.

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 3. Data Blocks +++
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
+++ 3.1 Data Block (general specification) +++

Data Blocks hold the data of the SADF file. 'Data' refers to both metadata and
normal data. All data block must start with the following structure:

[byte]	[type]	[field]
0,1     u16 	data block type (DB_TY)
2,3     u16     data block ID (DB_ID)
4,5     u16     DB_ID of associated metadata block (MD_ID)
...     raw     (data)

If a data block is linked to certain metadata (for instance, an image may be 
associated with a metadata block containing the telescope, location, time,
instrument etc...), then the data block identification number (DB_ID) of the
metadata block will be specified in the MD_ID field.

If a data block has no metadata associated with it, the MD_ID field shall be set
to 0x0000 (1).

Data block encoding, encrypting and signing is handled by the metadata block
associated with the data block. (see section 1.2). Further information can be
found in the metadata data block.

(1) The MD_ID value of 0x0000 is reserved for this use only. A SADF file may
    never contain an actual metadata block with DB_ID 0x0000.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 3.2 Metadata Data Block (DB_TY: 0xffff) +++

A metadata Data Block starts with the standard (mandatory) fields, followed by
(mandatory) metadata extension fields:

[byte]	[type]	[field]
0,1     u16 	data block type (DB_TY)
2,3     u16     data block ID (DB_ID) (1)
4,5     u16     DB_ID of associated metadata block (MD_ID) (2)
6,7     u16     compression type
8,9     u16     encryption type (3)
10      bool    signature present (MD_sig) (4)
...     ...     ...

Depending on the value of the MD_sig field, more required fields may follow (2):

IF MD_sig == true =>
[byte]	[type]	[field]
11-15   u32 	signature type (3)
15,16   u16     signature length (3)
...     raw     signature (3)

IF MD_sig == false =>
(no additonal fields)

The value of the compression type field indicates the type of compression used
for the data block(s) (5). Users may use the user-reserved range of the
compression type field to define their own compression algorithms. The following
values of the compression field are reserved:

[value] [compression type]
//General purpose
0x0000  no compression
0x0001  run-length encoding
0x0002  huffman encoding
0x0003  arithmetic encoding
0x0004  asymmetric number system (LZFSE)
0x0005  Lempel-Ziv compression (LZ77)
0x0006  Lempel-Ziv compression (LZ78)
0x0007  Lempel-Ziv-Szymanski (LZSS)
0x0008  Lempel-Ziv-Welch (LZW)
0x0009  Lempel-Ziv-Markov chain algorithm (LZMA)
0x000a  deflate
0x000b  Burrows-wheeler transform
0x000c  Prediction by partial matching (PPM)

//Image compression
0x0100  AOMedia video 1 image file format (AVIF)
0x0101  Free lossless image format (FLIF)
0x0102  High efficiency image file format (HEIF0)
0x0103  JBIG2
0x0104  JPEG 2000
0x0105  Discrete cosine transformation (LDCT)

//User reserved
0xb___  user-reserved range

After these required fields, an optional metadata table may follow, consisting
of an unordered list of Metadata Entries (ME). The metadata table cannot be
compressed, but it can be signed(3).

ME's are appended to the fields described above in arbitrary order, without
padding. ME's do not contain identification numbers, other than they keywords
themselves. Hence, ME's may not reference eachother, nor may external data
blocks refer to ME's.

For more information on ME's, consult the section on the Metadata Entry.

(1) The DB_ID field of any data block, including metadata blocks, may never be
    set to 0x0000. See Section 3.1 for details.

(2) The MD_ID field of a metadata block may be set to 0x0000 or to its own 
    DB_ID to indicate that no metadata other metadata blocks are connected to
    this metadata block. The MD_ID field may never be set to the DB_ID of one of
    the data blocks pointing to the metadata block. Setting the MD_ID field to
    any other value indicates is currently not standard-compliant, but may be
    used in the future to implement metadata inheritance.

(3) Encryption and digital signature standards are discussed in section 4. of
    this document. More information about these fields can be found there.

(4) To clarify: if the signed field is set to true, the signature fields MUST be
    specified. If the signed field is set to false, then the signature fields
    MUST be omitted.

(5) If multiple data blocks point to a single metadata block, all MUST be
    compressed in the same way, namely according to the compression type
    specified in the shared metadata block.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 3.2.1 Metadata Entry (ME) +++

A Metadata Entry is essentially a keyword-value pair (inspired by the keyword-
value pairs of the FITS standard). A metadata entry contains the following
fields:

[byte]	[type]	[field]
0       u08     keyword length
1-x     utf8    keyword
x,x+1   u16     data type (1)
x+2,... ...     value (2,3)

(1) for a list of data type codes and their associated data types, see section
    1.3 of this document.
(2) for data types with no fixed length (unsized data types), the first two 
    bytes of the value field MUST indicate the length of the value field. This
    is not required for data fields with a fixed data size. User-defined
    types are always unsized.
(3) The maximum length of the value field is 65•535 bytes. For values that take
    up more space than this maximum size, the use of seperate data blocks is
    required.

--------------------------------------------------------------------------------