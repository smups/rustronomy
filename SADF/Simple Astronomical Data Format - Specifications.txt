--------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++ SIMPLE ASTRONOMICAL DATA FORMAT +++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
--------------------------------------------------------------------------------

SADF - The Simple Astronomical Data Format
Version 1.0
Creation date: 01/12/2021
Author: Raúl Wolters (Instituut Lorentz, Universiteit Leiden, the Netherlands)
contact: rwolters@lorentz.leidenuniv.nl

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 1. Introduction +++
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
+++ 1.1 Raison d'être of SADF +++

The Simple Astronomical Data Format (SADF) was designed to improve upon the 
commonly used FITS standard developed by NASA in the 1970's for use in
astronomy. The FITS standard is rather clunky and does not support compression
or data verification methods natively. Despite these disadvantages, FITS is
still widely used within astronomy for it's versatility in allowing extensions
of the standard. SADF aims to keep best practices from FITS and improving upon
the less-than-ideal aspects of the FITS standard.

In additon, SADF is and always will be an open standard as per the definition of
the free software foundation. 

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 1.2 Overview +++

A SADF file consists of a header and data blocks. A SADF standard compliant file
must always contain a header. The header essentially serves as a table of
contents for the SADF file. Each data block present in the file is listed in the
header as a Header Index Block (HIB).

SADF files contain no padding between the header/datablocks. In additon, both
the header and data blocks may be of arbitrary length to allow flexible encoding
formats. For this reason, the header contains pointers (read: byte indices) and 
lengths for all data blocks, whereas the header itself always starts at index 0.

Data blocks can have various types. In this standard, metadata blocks, plain
text, up to 16-dimensional arrays and tables(maps) are supported. Users may also
extend the standard and define their own data block types.

Especially the metadata block type should be mentioned. Each data block may link
to a metadata block that contains metadata relevant to that data block. Multiple
data blocks may be associated with a single metadata block, but no more than one
metadata block can be assigned to each data block.

The SADF standard natively supports encryption, digital signing of data and
compression algorithms. If a data block is encrypted, signed or compressed, the
type of compression, type of encryption and signature are all stored in the
metadata block associated with the data block in question. The metadata(1) part
of the metadata block associated with a data block shall be appended to the data
block before signing/encrypting the pair, but after compressing the data block
itself, since data block compression must always take place before signing.

Data blocks (including metadata blocks) may appear in any order in a SADF file ( 
although none may appear before the header). Therefore, data blocks that refer 
to other data blocks must do so using the data block identification number 
(DB_ID). The header provides an index linking these DB_IDs to actual positions 
in the file using the ptr data type.

Finally, an example is shown of a possible SADF file:

[data block]    [short description]
header          6 data blocks: (1 -> ...), (2 -> ...), (3 -> ...) etc...
Data Block 1    (metadata for block 2 and 3)
Data Block 2    (data) -> (metadata) 1
Data Block 3    (data) -> (metadata) 1
Data Block 4    (metadata for block 6)
Data Block 5    (data) -> (no metadata) 0 
Data Block 6    (data) -> (metadata) 4
etc...

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 1.3 Data Types +++

[Code]	[Abbreviation]	[Description]
//Boolean
0x0000	bool		    8-bit boolean (0=true, else=false)

//Unsigned Integers
0x0008	u08		        unsigned 8-bit integer
0x0016 	u16		        unsigned 16-bit integer
0x0032 	u32		        unsigned 32-bit integer
0x0064 	u64		        unsigned 64-bit integer

//Signed Integers
0x0010 	i16		        signed 16-bit integer
0x0020 	i32		        signed 32-bit integer
0x0040 	i64		        signed 64-bit integer

//Signed floats
0x0f20 	f32		        signed 32-bit float (IEEE compliant)
0x0f40 	f64		        signed 64-bit float (IEEE compliant)

//Character Arrays
0xca08 	utf8		    UTF-8 encoded charachter array
0xca16  utf16           UTF-16 encoded charachter array

//Pointer
0xa064	ptr 		    64-bit pointer

//Complex numbers
0xc016  xu16            unsigned 16x2-bit complex integer number
0xc032  xu32            unsigned 32x2-bit complex integer number
0xc064  xu64            unsigned 64x2-bit complex integer number

0xc010  xi16            signed 16x2-bit complex integer number
0xc020  xi32            signed 32x2-bit complex integer number
0xc040  xi64            signed 64x2-bit complex integer number

0xcf20  xf32            signed 32x2-bit floating point complex number
0xcf40  xf64            signed 64x2-bit floating point complex number

//User defined types
0xb___  ...             (1) reserved for personal use

A range, written as x-y, includes x but excludes y.

(1) Users may define their own types in the 0xb___ range. These type definitions
    are not supported guaranteed to exist in standard-conforming implementations
    and hence must be implemented by the user themself.

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 2. The Header +++
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
+++ 2.1 Header +++

The header starts off with a u16 integer listing the number of data blocks,
followed by an unordered list of Header Index Blocks (HIB's). Note that each HIB
is 20 bytes long.

A header can, theoretically, hold 65•535 entries. This means that the maximum
header size is 1•310•702 bytes, or about 1.3MB. Hence, 1•310•702 bytes must
always be avaliable for header decoding in programs implementing SADF reading
functionality, unless the total file size is smaller than 1•310•702 bytes, in
which case the entire file must be loaded in one buffer in order to guarantee
the entire header is avaliable(1).

Note: Since the length of the data blocks is specified in the header, the 
required buffer size to read the data blocks is always known and no memory needs
to go to waste when copying the data blocks into memory, unlike in the header
reading process listed above.

[byte]	[field]
0-2	    number of indexed data blocks (required)
2-22	HIB #1 (optional)
22-42	HIB #2 (optional)
...	    ...
x-x+20	Final HIB

(1) This buffer need not be thrown away and may be re-used by the implementation
    to parse the remaining file contents.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
+++ 2.2 Header Index Block +++

A Header Index Block (HIB) points to a data block in the file. They are
used exclusively in the header part of the file. An HIB is always 20 bytes long.

[byte]	[type]	[field]
0,1     u16 	data block identification number (DB_ID)
2-10    ptr	    data block start (DB_ST)
10-18   u64	    data block length (DB_SI)
18,19   u16	    data block type identifier (DB_TY)

The identification number (DB_ID) of a data block serves for internal refrences;
i.e. when data blocks must refrence eachother. The Data Block Start (DB_ST)
pointer points to the byte index at which the data block in question starts.
The data block length (DB_SI) field specifies the length of the data blocks in
bytes.

Finally, the data block type identifier (DB_TY) specifies the format that was
used to store the data block. The following DB_TY values have specific meanings:

[value] [function]
0x0000  plain text
0x0001  1-dimensional array (1)
0x0002  2-dimensional array/image (1)
...     n-dimensional array (1)
0x000f  16-dimensional array (1)
0x00f0  table (2)
0xb___  user defined (3)
0xffff  metadata

(1) Arrays may only consist of one data type. For more information, see the 
    "Array Data Block (0x0001-0x000f)" section of this document.
(2) Tables may contain keyword - value pairs of arbitrary type, although all
    keywords and all values must have the same type. For more information, see
    the "Table Data Block (0x00f0)" section of this document.

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 3. Data Blocks +++
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
+++ 3.1 Data Block (general specification) +++

Data Blocks hold the data of the SADF file. 'Data' refers to both metadata and
normal data. Each data block starts with the following structure:

[byte]	[type]	[field]
0,1     u16 	data block type (DB_TY)
2,3     u16     data block ID (DB_ID)
4,5     u16     DB_ID of associated metadata block (MD_ID)
...     ...     (data)

If a data block is linked to certain metadata (for instance, an image may be 
associated with a metadata block containing the telescope, location, time,
instrument etc...), then the data block identification number (DB_ID) of the
metadata block will be specified in the MD_ID field.

If a data block has no metadata associated with it, the MD_ID field shall be set
to 0x0000 (1).

Data block encoding, encrypting and signing is handled by the metadata block
associated with the data block. (see section 1.2). Further information can be
found in the metadata data block.

(1) The MD_ID value of 0x0000 is reserved for this use only. A SADF file may
    never contain an actual metadata block with DB_ID 0x0000.

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ 3.2 Metadata Data Block (DB_TY: 0xffff) +++

A metadata Data Block starts with an index table, containing metadata index
blocks (MIB's)

[byte]	[type]	[field]
0,1     u16     number of metadata tables
2-20    MIB #1  first entry in the index table
...     MIB #n  last entry in the index table
...     MDT #1  first metadata table
...     MDT #n  last metadata table


--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
+++ Metadata Index Block +++

The MIB is always 18 bytes long.

[byte]	[type]	[field]
0,1     u16     IDN of data block that this table refers to
2-10	ptr		table start
10-18	u64		table length

--------------------------------------------------------------------------------
